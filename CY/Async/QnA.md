> Q.자바스크립트의 비동기 처리에 대해 설명해주세요.

비동기처리란 현재 실행 중인 태스크가 종료되지 않은 상태여도 다음 태스크를 바로 실행할 수 있는 방식으로 태스크들에 대한 블로킹이 발생하지 않으며 태스크의 실행 순서가 보장되지 않는 특징을 가집니다. setTimeout/setInterval, HTTP 요청, 이벤트 핸들러가 비동기 처리 방식으로 동작합니다.

반면에 동기 처리는 실행중인 태스크가 종료될 때까지 다음 태스크가 대기하는 방식으로, 실행 순서가 보장되지만 앞선 태스크가 종료될 때까지 이후 태스크들이 블로킹되는 단점이 있습니다.

(+자바스크립트 엔진은 하나의 실행 컨택스트 스택을 가져서 한 번에 하나의 함수만 실행할 수 있는 싱글 스레드 방식으로 동작하는데, 브라우저는 멀티 스레드로 동작하고 태스크 큐와 이벤트 루프가 내장되어 있어 자바스크립트의 동시성을 지원합니다. 비동기 처리 방식으로 동작하는 것들은 태스크 큐라는 곳에서 대기하고 있다가, 콜 스택이 빌 경우 이벤트 루프가 그것들을 순차적으로 콜 스택으로 이동시켜 함수가 실행되는 원리로 동작합니다.

함수를 호출하면 함수 코드가 평가되어 함수 실행 컨텍스트가 생성됩니다. 이 실행 컨텍스트는 실행 컨텍스트 스택에 푸시되고 함수 코드가 실행됩니다. 함수 코드의 실행이 종료하면 실행 컨택스트는 실행 컨택스트 스택에서 팝되어 제거됩니다.)


> Q. 비동기 함수에 대해 설명해주세요.

비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.

> Q. 콜백 함수란 무엇인가요?ˀ 콜백 지옥을 해결하기 위한 방법은 무엇인가요?

콜백함수란 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 말합니다. 

콜백 헬: 비동기를 처리하기 위해 콜백 함수를 사용할 때 그 비동기 결과에 대한 처리를 또 해야한다면 콜백 함수 호출을 중첩되게 여러번 하여 복잡성이 높아지는 현상

이를 해결하기 위해 Promise를 사용하여 콜백지옥을 해결 할 수 있습니다. 

> Q. Promise란 무엇이며 코드가 어떻게 구성되어있는가
프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체이다. 비동기 처리가 진행되는 것을 나타내는 상태 정보를 가진다.

생성 방법: new 연산자와 함께 Promise 생성자 함수를 호출

Promise 생성자 함수는 비동기 처리를 수행하는 콜백 함수를 인수로 전달받아서 비동기 처리를 수행하고, 처리가 성공하면 resolve 함수에 인수로 비동기 처리 결과를 전달하여 호출하고, 처리가 실패하면 reject 함수에 에러를 인수로 전달하여 호출한다.

프로미스 상태: 비동기 처리가 아직 수행되지 않은 상태(pending), 비동기 처리가 성공적으로 완료된 상태(fulfilled), 비동기 처리가 실패한 상태(rejected)

then, catch, finally 같은 후속 처리 메서드를 이용하여 비동기 처리 결과를 받아서 처리할 수도 있다. then은 프로미스 처리가 완료된 상태가 되면 호출되고, catch는 프로미스 처리 결과가 rejected이면 호출되어 에러를 처리할 때 쓸 수 있다. finally는 프로미스의 상태와 상관 없이 무조건 한 번 호출된다.

프로미스 체이닝은 then, catch, finally 같은 후속 처리 메서드가 프로미스를 반환하기 때문에 연속적으로 호출할 수 있는 것을 말한다.

후속 처리 메서드를 이용해 처리 결과를 가지고 다른 작업을 실행할 수 있어 중첩되는 구조를 피할 수 있다.

promise.all: 파라미터로 배열을 받으며, 서로 영향을 미치지 않는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용

> Q. Async, Await가 무엇인지 설명해달라
> 
프로미스를 기반으로 동작하며 프로미스가 처리 결과를 반환하게 할 수 있는 문법. async 키워드를 이용해 함수를 정의하고, 그 내부에서 프로미스 앞에 await 키워드를 사용할 수 있는데, 프로미스의 상태가 완료될 때까지 기다리고 그 결과를 반환받을 수 있어 이를 이용해서 비동기를 동기적으로 처리할 수 있다. 에러 처리를 위해 try catch문을 사용할 수 있다.

> Q. Promise와 Callback 차이는 무엇이며 각각의 장단점에 대해 설명해달라
> 
둘 다 자바스크립드에서 비동기 처리를 위해서 사용되는 패턴이며,

Callback 같은 경우 함수의 처리 순서를 보장하기 위해서 함수를 중첩하게 사용되는 경우가 발행해
콜백헬이 발행하는 단점과 에러 처리가 힘들다라는 단점이 있다.

그래서 나온게 Promise이며 ES6부터 정식 채택되어 사용중이다.

Promise 생성자 함수를 통해 인스턴스화하며,
비동기 처리에 성공하면 resolve 메소드를 호출해서 비동기 처리 결과를 후속처리 메소드로 전달한다.

비동기 처리에 실패하면 reject 메소드를 호출해서 에러 메세지를 후속처리 메소드로 전달한다.

후속처리 메소드를 then과 catch가 있다. 둘 다 Promise를 반환한다.

then을 가지고 메소드 체이닝을 통하여서 콜백헬 문제를 해결할 수 있다.
출처 : https://danbom425.tistory.com/34,
https://hoho-hobi.tistory.com/154?category=892297

> Q.프로미스와 async/await의 차이점은 무엇인가요? 프로미스의 상태 변화에 대해 설명해주세요

promise를 활용할 시에는 then을 여러 번 사용할 경우 가독성이 안좋아질 수 있고, 에러 핸들링을 할 때 catch() 메서드를 이용해 할 수 있다. async await은 프로미스 후속 처리 메서드 없이 동기 처리처럼 프로미스가 결과를 반환할 때까지 기다려 가독성이 좋아지고, try-catch문으로 에러 핸들링을 한다.

프로미스의 상태변화
프로미스 상태: 비동기 처리가 아직 수행되지 않은 상태(pending), 비동기 처리가 성공적으로 완료된 상태(fulfilled), 비동기 처리가 실패한 상태(rejected)

출처 : https://dal-dagury.tistory.com/76